#### Notas misceláneas surgidas durante el proceso de análisis
---

Durante las fases del análisis, tanto estático, como dinámico, van surgiendo diferentes temáticas y situaciones que hay que documentar, bien por ser importantes para el proceso general, o bien por ser puntos interesantes en los que indagar más posteriormente. A continuación, se recogen las anotaciones hasta el momento en orden cronológico: 

- [Genymotion](https://www.genymotion.com/) permite los dispositivos rooteados (por defecto en su versión personal gratuita), lo cual facilita el proceso de hooking con FRIDA. Se intentó utilizar Frida junto con el emulador de Android Studio, pero sería necesario hacer un repackaging de las aplicaciones de muestra de malware para permitir el hooking. No obstante, se seguirá utilizando Android Studio durante el proyecto, ya que ofrece configuraciones adicionales que podrían ser útiles durante el análisis dinámico, como la emulación de huella dactilar o el debugging directo con la APK original, de las que Genymotion carece.

- Tras la instalación de Chameleon (muestra Google Chrome 0a6ffd4163cd96d7d262be5ae7fa5cfc3affbea822d122c0803379d78431e5f6.apk), y previamente a la otorgación de permisos por parte del usuario, al no haber sido abierta la aplicación tras su instalación, esta se encuenta en el bucket NEVER (más información en https://developer.android.com/topic/performance/appstandby), lo que limita su acceso a recursos hasta que el usuario ejecuta la aplicación y le otorga permisos. Esto se ve reflejado en los logs del dispositivo emulado (accesibles mediante adb).

- El archivo hello.txt en la carpeta de recursos parece estar codificado en base64 y ser un archivo de internacionalización del mecanismo para obtener permisos.

- El archivo kx.json en /data/user/0/com.busy.lady/app_DynamicOptDex es en realidad un fichero ZIP que contiene classes.dex y parece ser utilizado para cargar dinámicamente las clases.

- [QuarkEngine](https://github.com/quark-engine/quark-engine) puede servir para generar análisis automáticos.

- El malware genera datos sobre la instalación de la aplicación (timestamp), bajo "uninstall_metrics" y posibles datos de entropía para la ofuscación, todo ello almacenado en el archivo JSON pref_store.

- En el mismo directorio que pref_store se encuentran archivos de variaciones de seed y stamp, posiblemente utilizados en el proceso de ofuscación.

- En el directorio de cache bajo WebView se encuentran varios archivos hex con el mismo inicio 305c 72a7, posiblemente archivos en formato Simple File de Google (a investigar).

- Directorio databases contiene una base de datos SQLite con tablas modules, apps, keylogger y servers entre otras. Una vez cargada la BD con DB Browser se obtienen los primeros datos. El locale del sistema en el que está instalado el navegador y dos servers diferentes (posibles IoC): http://fastmainlines[.]co.in:45349 y http://fastmainlines[.]co.in:555 .

- El malware podría estar utilizando [ACRA](https://github.com/ACRA/acra) para el crash reporting, ya que se encuentran dos directorios relacionados en la partición de datos del dispositivo.

- Posible uso de DNSChef para el control del DNS del dispositivo infectado y la redirección de su C2 a nuestro propio server local. ./dnschef.py --fakeip 127.0.0.1  --fakealias fastmainlines.co.in -q.

- En AndroidManifest.xml se abusa del sistema de prioridad para hacer que la actividad siempre responda a la gestión de intents, asignando prioridad 999 pero no utilizando ninguna de las acciones que provocaría un reseteo de la prioridad (más información al respecto en https://developer.android.com/guide/topics/manifest/intent-filter-element).

- Al arrancar intenta una conexión a la API del C2: http://fastmainlines[.]co.in:45349/api/v1/bots/ffffffff-b4db-0685-0000-00004335a1df . El parámetro de bot en la URI de la API se corresponde con el nombre de la base de datos creada previamente. Es posible que este sea el identificador del dispositivo infectado desde la perspectiva de los atacantes.

- Posteriormente hace una petición GET a http://fastmainlines[.]co.in:45349/api/v1/bots/ffffffff-b4db-0685-0000-00004335a1df/tasks . Este endpoint presumiblemente sirve para enviar comandos al troyano.

- A continuación, se realiza una petición GET a http://fastmainlines[.]co.in:45349/ip .

- Tras el fallo de respuesta del primer puerto, hace una petición GET a otro puerto en el mismo servidor: http://fastmainlines[.]co.in:555/ip .

- De no progresar las peticiones o no obtener respuesta, la aplicación sigue iterando peticiones entre los dos puertos del servidor C2. Esto ha sido comprobado utilizando un proxy local que recibe las peticiones pero no responde a ellas.