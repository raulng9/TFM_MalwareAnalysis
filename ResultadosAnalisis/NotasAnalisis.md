#### Notas misceláneas surgidas durante el proceso de análisis
---

Durante las fases del análisis, tanto estático, como dinámico, van surgiendo diferentes temáticas y situaciones que hay que documentar, bien por ser importantes para el proceso general, o bien por ser puntos interesantes en los que indagar más posteriormente. A continuación, se recogen las anotaciones hasta el momento en orden cronológico: 

- [Genymotion](https://www.genymotion.com/) permite los dispositivos rooteados (por defecto en su versión personal gratuita), lo cual facilita el proceso de hooking con FRIDA. Se intentó utilizar Frida junto con el emulador de Android Studio, pero sería necesario hacer un repackaging de las aplicaciones de muestra de malware para permitir el hooking. No obstante, se seguirá utilizando Android Studio durante el proyecto, ya que ofrece configuraciones adicionales que podrían ser útiles durante el análisis dinámico, como la emulación de huella dactilar o el debugging directo con la APK original, de las que Genymotion carece.

- Tras la instalación de Chameleon (muestra Google Chrome 0a6ffd4163cd96d7d262be5ae7fa5cfc3affbea822d122c0803379d78431e5f6.apk), y previamente a la otorgación de permisos por parte del usuario, al no haber sido abierta la aplicación tras su instalación, esta se encuenta en el bucket NEVER (más información en https://developer.android.com/topic/performance/appstandby), lo que limita su acceso a recursos hasta que el usuario ejecuta la aplicación y le otorga permisos. Esto se ve reflejado en los logs del dispositivo emulado (accesibles mediante adb).

- El archivo hello.txt en la carpeta de recursos parece estar codificado en base64 y ser un archivo de internacionalización del mecanismo para obtener permisos.

- El archivo kx.json en /data/user/0/com.busy.lady/app_DynamicOptDex es en realidad un fichero ZIP que contiene classes.dex y parece ser utilizado para cargar dinámicamente las clases.

- [QuarkEngine](https://github.com/quark-engine/quark-engine) puede servir para generar análisis automáticos.

- El malware genera datos sobre la instalación de la aplicación (timestamp), bajo "uninstall_metrics" y posibles datos de entropía para la ofuscación, todo ello almacenado en el archivo JSON pref_store.

- En el mismo directorio que pref_store se encuentran archivos de variaciones de seed y stamp, posiblemente utilizados en el proceso de ofuscación.

- El archivo de preferencias en /data/user/0/com.busy.lady/shared_prefs/com.busy.lady_preferences.xml cuenta con un backup (/data/user/0/com.busy.lady/shared_prefs/com.busy.lady_preferences.xml.bak) y es el resultado de escribir un hashmap (mapToWriteToDisk, tamaño 28 entradas en el momento del debugging). Ejemplo sfURt5uxvIwIx0P2XxiPACsQTlAx0P3Xxx0P3Xx -> 3riQRN6x0P2XxlDjnhyKZiqtzRQx0P3Xxx0P3Xx. x0P3Xxx0P3Xx parece un sufijo constante tanto en keys como en valores del mapa. "x0P3Xx" es al parecer el encoding utilizado para "=", aplicado en Xkfbfe84cef7a9f7c4595bb46be09ddbb.

- Tareas de encriptación de las preferencias englobadas en la clase Xkfbfe84cef7a9f7c4595bb46be09ddbb (renombrada a EncryptService). Encriptación realizada con el método AES/CBC/PKCS7Padding y la clave privada en la variable D897b257e (o D12047c33 originalmente, renombrada a encryptionPassword en JADX). Desencriptación realizada en DecryptService (Xk84162b0ed689abb75046ba63b5af786). La variable se instancia por el atacante en Builder.withEncryptionPassword(encryptionKey) de acuerdo con la traza del RuntimeError en el caso de estar vacía. Además de encriptar, previamente se realiza un encoding de los valores en base64.

- En el directorio de cache bajo WebView se encuentran varios archivos hex con el mismo inicio 305c 72a7, posiblemente archivos en formato Simple File de Google (a investigar).

- Directorio databases contiene una base de datos SQLite con tablas modules, apps, keylogger y servers entre otras. Una vez cargada la BD con DB Browser se obtienen los primeros datos. El locale del sistema en el que está instalado el navegador y dos servers diferentes (posibles IoC): http://fastmainlines[.]co.in:45349 y http://fastmainlines[.]co.in:555 .

- El malware podría estar utilizando [ACRA](https://github.com/ACRA/acra) para el crash reporting, ya que se encuentran dos directorios relacionados en la partición de datos del dispositivo.

- Posible uso de DNSChef para el control del DNS del dispositivo infectado y la redirección de su C2 a nuestro propio server local. ./dnschef.py --fakeip 127.0.0.1  --fakealias fastmainlines.co.in -q.

- En AndroidManifest.xml se abusa del sistema de prioridad para hacer que la actividad siempre responda a la gestión de intents, asignando prioridad 999 pero no utilizando ninguna de las acciones que provocaría un reseteo de la prioridad (más información al respecto en https://developer.android.com/guide/topics/manifest/intent-filter-element).

- Al arrancar intenta una conexión a la API del C2: http://fastmainlines[.]co.in:45349/api/v1/bots/ffffffff-b4db-0685-0000-00004335a1df . El parámetro de bot en la URI de la API se corresponde con el nombre de la base de datos creada previamente. Es posible que este sea el identificador del dispositivo infectado desde la perspectiva de los atacantes. Nuevo: Este identificador se calcula en base a datos del dispositivo infectado en Xk0468bb233eb83b985c75eab5ccafc80 (modelo, pantalla, CPU...).

- Posteriormente hace una petición GET a http://fastmainlines[.]co.in:45349/api/v1/bots/ffffffff-b4db-0685-0000-00004335a1df/tasks . Este endpoint presumiblemente sirve para enviar comandos al troyano.

- A continuación, se realiza una petición GET a http://fastmainlines[.]co.in:45349/ip .

- Tras el fallo de respuesta del primer puerto, hace una petición GET a otro puerto en el mismo servidor: http://fastmainlines[.]co.in:555/ip .

- De no progresar las peticiones o no obtener respuesta, la aplicación sigue iterando peticiones entre los dos puertos del servidor C2. Esto ha sido comprobado utilizando un proxy local que recibe las peticiones pero no responde a ellas.

- Dentro de la carpeta de recursos assets se ha encontrado un archivo offlivemapv4.png que contiene datos JSON sobre ciudades en China, con información como URLs de descarga (archivos .ASN), códigos identificativos. Podría estar relacionado con un sistema de publicidad.

- Petición GET encontrada durante debugging: Request{method=GET, url=http://fastmainlines.co.in:45349/socket.io/?uid=ffffffff-b4db-0685-0000-00004335a1df&password=IamTheStrongestMANOMAN&EIO=4&transport=websocket, headers=[Upgrade:websocket, Connection:Upgrade, Sec-WebSocket-Key:5VXP8PZl4jLLnuve3q8Mbw==, Sec-WebSocket-Version:13, Sec-WebSocket-Extensions:permessage-deflate]}.

- Según los datos al cargar el APK base, la compilación objetivo es la API 26 del SDK de Android (default:targetSdkVersion=26). Se busca esconder el icono de esta APK base (showUserIcon -10000).

- Método de autodefensa en Xk0c7942b88a0a2d4483fe3bdcf95ead7 (dex), primera referencia explícita a la familia Chameleon.

- Interacción con accesibilidad en AccesibilityServImplBase (renombrada).